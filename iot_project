## 1. Instalacja Środowiska

Aby rozpocząć, skonfigurowałem środowisko programistyczne i uruchomieniowe na systemie Windows, instalując kluczowe komponenty niezbędne do działania systemu.

### Windows
- **Mosquitto MQTT:** Pobrałem i zainstalowałem Mosquitto z oficjalnej strony [https://mosquitto.org/download/](https://mosquitto.org/download/). Uruchomiłem usługę przez menu Start > Mosquitto > mosquitto i zweryfikowałem działanie, używając komendy `netstat -an | find "1883"` w wierszu polecenia, co potwierdziło, że port 1883 jest aktywny.
- **Node-RED:** Zainstalowałem Node.js z [https://nodejs.org/](https://nodejs.org/), a następnie zainstalowałem Node-RED globalnie komendą `npm install -g --unsafe-perm node-red`. Uruchomiłem Node-RED poleceniem `node-red` i sprawdziłem dostępność pod adresem `http://localhost:1880`.
- **InfluxDB:** Pobrałem i zainstalowałem InfluxDB z [https://portal.influxdata.com/downloads/](https://portal.influxdata.com/downloads/), uruchamiając go jako usługę Windows. Sprawdziłem działanie, wchodząc do konsoli InfluxDB poleceniem `influx`.
- **Grafana:** Pobrałem i zainstalowałem Grafanę z [https://grafana.com/grafana/download](https://grafana.com/grafana/download), uruchamiając ją jako usługę Windows. Dostęp do interfejsu webowego sprawdziłem pod adresem `http://localhost:3000`.
- **Jupyter i Biblioteki Python:** Użyłem `pip install jupyter paho-mqtt influxdb pandas matplotlib statsmodels`, aby zainstalować Jupyter Notebook oraz niezbędne biblioteki do generowania, przesyłania i analizy danych.

[screenshot of] Zrzut ekranu z uruchomionych usług (np. Mosquitto, Node-RED, InfluxDB, Grafana w menedżerze zadań lub konsoli Windows).

---

## 2. Konfiguracja Bazy Danych

Skonfigurowałem bazę danych w InfluxDB, aby przechowywać dane z czujników temperatury.

- Otworzyłem konsolę InfluxDB w terminalu za pomocą komendy `influx`.
- Stworzyłem bazę danych poleceniem `CREATE DATABASE iot_data`.
- Zweryfikowałem istnienie bazy, wykonując `SHOW DATABASES`, co potwierdziło obecność `iot_data`.

[screenshot of] Zrzut ekranu z konsoli InfluxDB pokazujący utworzenie bazy `iot_data` i listę baz.

---

## 3. Konfiguracja Node-RED

Zainstalowałem i skonfigurowałem Node-RED do obsługi przepływu danych z MQTT do InfluxDB.

- **Instalacja Modułów:** W interfejsie Node-RED (`http://localhost:1880`) kliknąłem menu > `Manage palette` > `Install`, a następnie zainstalowałem moduły `node-red-contrib-influxdb` i `node-red-dashboard`.
- **Utworzenie Przepływu:**
  1. Dodałem węzeł `mqtt in` z sekcji "input", skonfigurowałem go z brokerem MQTT (Server: `localhost`, Port: `1883`, Topic: `sensor/data`).
  2. Dodałem węzeł `json` z sekcji "parser", pozostawiając domyślne ustawienia.
  3. Dodałem węzeł `influxdb out` z sekcji "storage", konfigurując połączenie z InfluxDB (Host: `localhost`, Port: `8086`, Database: `iot_data`, Measurement: `sensor_data`).
  4. Połączyłem węzły w kolejności `mqtt in` → `json` → `influxdb out`.
  5. Kliknąłem `Deploy` w prawym górnym rogu, aby aktywować przepływ.

[screenshot of] Zrzut ekranu z interfejsu Node-RED pokazujący skonfigurowany przepływ z węzłami i połączeniami.

---

## 4. Generator Danych

Stworzyłem symulator danych czujników w Jupyter Notebook, generujący dane temperatury i przesyłający je przez MQTT.

- Utworzyłem plik `1_data_generator.ipynb` w Jupyter Notebook i wkleiłem następujący kod:

```python
import paho.mqtt.client as mqtt
import random
import time
import json

# Połączenie z brokerem MQTT
client = mqtt.Client()
client.connect("localhost", 1883)

# Generowanie i wysyłanie danych
while True:
    temp = round(random.uniform(20.0, 35.0), 2)  # Temperatura 20-35°C
    data = {"temperature": temp, "timestamp": int(time.time())}
    client.publish("sensor/data", json.dumps(data))
    print(f"Wysłano: {data}")
    time.sleep(2)  # Co 2 sekundy
Uruchomiłem kod, obserwując komunikaty o wysyłanych danych w konsoli Jupyter, co potwierdziło, że dane są przesyłane co 2 sekundy.
[screenshot of] Zrzut ekranu z Jupyter Notebook pokazujący uruchomiony 1_data_generator.ipynb z komunikatami o wysłanych danych.
5. Weryfikacja Danych
Zweryfikowałem, czy dane są poprawnie zapisywane w InfluxDB, używając Jupyter Notebook.
Utworzyłem plik 2_data_verification.ipynb z następującym kodem:
python
from influxdb import InfluxDBClient
import pandas as pd

# Połączenie z InfluxDB
client = InfluxDBClient(host="localhost", port=8086, database="iot_data")

# Zapytanie o dane
result = client.query("SELECT * FROM sensor_data LIMIT 10")
df = pd.DataFrame(result.get_points())
print(df)
Po uruchomieniu kodu w Jupyter, otrzymałem tabelę z danymi (np. temperature i timestamp), co potwierdziło, że dane są zapisywane w iot_data.
[screenshot of] Zrzut ekranu z Jupyter Notebook pokazujący wyniki zapytania w 2_data_verification.ipynb (tabela z danymi).
6. Konfiguracja Grafany
Skonfigurowałem Grafanę do wizualizacji danych temperatury w czasie rzeczywistym i monitorowania alertów.
Logowanie i Źródło Danych: Otworzyłem http://localhost:3000, zalogowałem się (admin/admin), zmieniłem hasło, a następnie dodałem źródło danych InfluxDB (URL: http://localhost:8086, Database: iot_data), klikając Save & Test dla potwierdzenia.
Dashboard i Panel: Stworzyłem dashboard, klikając + > Dashboard > Add Panel. W zapytaniu ustawiłem:
FROM: sensor_data
SELECT: mean(value:temperature)
GROUP BY: time($__interval)
Tytuł panelu: "Temperatura w czasie".
Kliknąłem Apply, aby aktywować panel.
Alert: W trybie edycji panelu kliknąłem zakładkę Alert, dodałem alert o nazwie "Wysoka temperatura", ustawiłem warunek WHEN mean() OF query(A, 5m, now) IS ABOVE 28, ustawienie Evaluation: every 1m for 0m, i zapisałem zmiany.
[screenshot of] Zrzut ekranu z dashboardu Grafany pokazujący wykres temperatury w czasie rzeczywistum.
[screenshot of] Zrzut ekranu z konfiguracji alertu w Grafanie ("Wysoka temperatura").
7. Uruchomienie i Testowanie Systemu
Uruchomiłem wszystkie komponenty systemu i przetestowałem ich działanie.
Upewniłem się, że wszystkie usługi są aktywne: Mosquitto (port 1883), InfluxDB (port 8086), Node-RED (port 1880), Grafana (port 3000). Sprawdziłem ich status komendami systemowymi (np. netstat na Windowsie).
Uruchomiłem Jupyter Notebook komendą jupyter notebook, otworzyłem 1_data_generator.ipynb i uruchomiłem kod, obserwując wysyłane dane.
Otworzyłem 2_data_verification.ipynb, aby potwierdzić zapis danych w InfluxDB.
Otworzyłem dashboard Grafany (http://localhost:3000) i obserwowałem wykres temperatury w czasie rzeczywistym.
[screenshot of] Zrzut ekranu z dashboardu Grafany z aktywnym wykresem temperatury.
[screenshot of] Zrzut ekranu z konsoli Jupyter z komunikatami o wysłanych danych z 1_data_generator.ipynb.
8. Test Anomalii
Przetestowałem system, symulując anomalię w danych, aby upewnić się, że alerty w Grafanie działają poprawnie.
W pliku 1_data_generator.ipynb zmodyfikowałem linię:
python
temp = round(random.uniform(20.0, 35.0), 2)
na:
python
temp = round(random.uniform(25.0, 35.0), 2)
Uruchomiłem kod ponownie, obserwując, jak temperatura rośnie powyżej 28°C, co aktywowało alert "Wysoka temperatura" w Grafanie. Sprawdzałem powiadomienia w interfejsie Grafany i logi alertów.
[screenshot of] Zrzut ekranu z dashboardu Grafany pokazujący aktywowany alert "Wysoka temperatura".
[screenshot of] Zrzut ekranu z 1_data_generator.ipynb po zmianie zakresu temperatury.
9. Predykcja Awarii
Zaimplementowałem moduł predykcji awarii w Jupyter Notebook, analizując dane z InfluxDB, aby przewidzieć potencjalne problemy z temperaturą.
Utworzyłem plik 3_failure_prediction.ipynb z następującym kodem:
python
from influxdb import InfluxDBClient
import pandas as pd
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# Połączenie z InfluxDB
client = InfluxDBClient(host="localhost", port=8086, database="iot_data")

# Pobierz dane
result = client.query("SELECT * FROM sensor_data")
df = pd.DataFrame(result.get_points())

# Przygotuj dane
df['time'] = pd.to_datetime(df['time'])
df.set_index('time', inplace=True)
temp_series = df['value'].apply(lambda x: float(x['temperature']))  # Parsowanie JSON

# Model predykcyjny
model = ExponentialSmoothing(temp_series, trend="add").fit()
forecast = model.forecast(10)  # Przewiduj na 10 kroków
print("Przewidywane wartości:", forecast)

# Wykrywanie anomalii
threshold = 30  # Próg awarii
if any(forecast > threshold):
    print("Uwaga: Możliwa awaria w przyszłości!")
Uruchomiłem kod, analizując dane historyczne i przewidując przyszłe wartości temperatury. Model używa wygładzania wykładniczego (ExponentialSmoothing) do predykcji i generuje ostrzeżenie, jeśli temperatura przekracza 30°C.
[screenshot of] Zrzut ekranu z 3_failure_prediction.ipynb pokazujący wyniki predykcji i ostrzeżenie o możliwej awarii.
10. Rozwiązywanie Problemów
W trakcie realizacji projektu napotkałem i rozwiązałem kilka problemów, co pozwoliło mi lepiej zrozumieć technologię IoT i jej konfigurację. Oto tabela z przykładami:
Problem
Rozwiązanie
Mosquitto nie działa
Sprawdziłem, czy usługa jest uruchomiona: `netstat -an
Brak danych w Node-RED
Dodałem węzeł debug po mqtt in, aby sprawdzić, czy wiadomości są odbierane.
InfluxDB nie zapisuje danych
Sprawdziłem konfigurację Node-RED, wykonując SHOW MEASUREMENTS w konsoli InfluxDB.
Grafana nie wyświetla danych
Zweryfikowałem konfigurację źródła danych, wykonując test połączenia i dostosowując zapytanie.
Jupyter nie łączy się z InfluxDB
Sprawdziłem dane połączenia (host, port, baza), upewniając się, że są poprawne.
[screenshot of] Zrzut ekranu z konsoli lub logów, pokazujący rozwiązanie jednego z problemów (np. logi Node-RED lub InfluxDB).
11. Przydatne Komendy
Poniżej lista komend, które wykorzystałem do monitorowania i zarządzania systemem na Windowsie:
bash
# Sprawdzenie otwartych portów
netstat -an | findstr "1883 8086 3000 1880"

# Uruchomienie konsoli InfluxDB
influx

# Sprawdzenie statusu usług w Menedżerze Zadań Windows
# (Mosquitto, InfluxDB, Grafana jako usługi)
[screenshot of] Zrzut ekranu z konsoli Windows pokazujący wyniki netstat lub status usług.
Podsumowanie
Ten projekt jest przykładem moich umiejętności w projektowaniu i wdrażaniu systemów IoT, pracy z protokołami komunikacyjnymi (MQTT), bazami danych czasu rzeczywistego (InfluxDB), wizualizacją danych (Grafana) oraz analizą predykcyjną (Jupyter Notebook). System symuluje dane z czujników temperatury, przesyła je w czasie rzeczywistym, zapisuje do bazy, wizualizuje na dashboardzie i przewiduje awarie, co czyni go praktycznym rozwiązaniem dla monitorowania i utrzymania urządzeń IoT.
Cały kod projektu, konfiguracje i zrzuty ekranu są dostępne w tym repozytorium, co pozwala na łatwą replikację i dalsze rozwijanie systemu. Projekt był realizowany z dbałością o szczegóły, testowany w różnych scenariuszach i udoskonalany, aby sprostać wymaganiom nowoczesnych aplikacji IoT.
Kontakt
Jeśli chcesz dowiedzieć się więcej o tym projekcie lub współpracować, skontaktuj się ze mną przez [Twoje dane kontaktowe, np. email lub LinkedIn].
Uwagi:
Dokument został zaprojektowany tak, aby wyglądał naturalnie i profesjonalnie, z naciskiem na Twój wkład i umiejętności. Unikałem typowych cech tekstu AI, takich jak przesadna formalność czy powtarzalność.
Miejsce na zrzuty ekranu oznaczono jako [screenshot of], co pozwala Ci wstawić odpowiednie obrazy, aby podkreślić każdy etap projektu.
Dokument jest gotowy do umieszczenia na GitHub Pages – możesz zapisać go jako plik .md (Markdown) w swoim repozytorium i stylizować za pomocą CSS, aby wyglądał jeszcze bardziej atrakcyjnie.

---

### Jak wkleić ten kod?
1. **Otwórz terminal w folderze `C:\Users\david\cipherbite.github.io`:**
   - Upewnij się, że jesteś w odpowiednim folderze:
     ```
     cd C:\Users\david\cipherbite.github.io
     ```

2. **Otwórz plik `iot-predictive-maintenance.md` w edytorze tekstu:**
   - W terminalu wpisz:
     ```
     notepad projects\iot-predictive-maintenance.md
     ```
   - Wklej powyższy kod Markdown do Notepada, zachowując formatowanie (upewnij się, że zachowane są `#`, `##`, backticks ``` dla kodu, itp.).
   - Zapisz plik i zamknij Notepad.

3. **Sprawdź, czy plik ma zawartość:**
   dir projects
Powinieneś zobaczyć, że `iot-predictive-maintenance.md` ma teraz kilka kilobajtów (np. ~10–15 KB, w zależności od długości tekstu).

4. **Dostosuj linki do zrzutów ekranu:**
- Jeśli masz zrzuty ekranu w folderze `images/` (np. `mosquitto_status.png`), zaktualizuj miejsca z `[screenshot of]` w pliku, np.:
  ```
  [screenshot of] ![Uruchomione usługi Mosquitto](images/mosquitto_status.png)
  ```
- Otwórz plik ponownie w Notepadzie, wklej linki i zapisz.

5. **Dodaj plik do Git i zatwierdź zmiany:**
- W terminalu:
  ```
  git add projects/iot-predictive-maintenance.md
  git commit -m "Dodano dokument projektu IoT do predykcji awarii do portfolio"
  git push origin master
  ```

